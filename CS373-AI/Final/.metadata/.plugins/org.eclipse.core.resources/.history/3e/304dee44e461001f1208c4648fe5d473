package project;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.StreamTokenizer;
import java.util.ArrayList;
import java.util.Random;

import project.ImitationSim.PieceType;

import mdps.Gridworld.GridworldAction;

public class ChessBoard{
	
	private static final double NOISE_LEVEL = 0.05;
	private int[][] stateLabels;
    private ArrayList<Coordinate> stateList = new ArrayList<Coordinate>();
    private int numStates;
	
	Piece[][] board;
	private int xDim, yDim;
	private boolean[][] wallMatrix;
	private double[][] rewardMatrix;
	private PieceType mentorType;
	private PieceType observerType;
	private PieceAction[] mentorActions;
	private PieceAction[] observerActions;
	private int[] observerActionIds;
	private int[] mentorActionIds;
	
	public int sizeX(){
		return xDim;
	}
	
	public int sizeY(){
		return yDim;
	}
	
	public int numStates(){
		return numStates;
	}
	
	public PieceAction[] getMentorActions(){
		return mentorActions;
	}
	
	public PieceAction[] getObserverActions(){
		return observerActions;
	}

	public ChessBoard(String fileName, PieceType m, PieceType o) {
		mentorType = m;
		observerType = o;
        // read in the array of locations
        try {
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            StreamTokenizer token = new StreamTokenizer(reader);
            token.nextToken();
            xDim = (int) token.nval;
            token.nextToken();
            yDim = (int) token.nval;
            wallMatrix = new boolean[xDim][yDim];
            rewardMatrix = new double[xDim][yDim];
            for (int i = 0; i < xDim; i++) {
                for (int j = 0; j < yDim; j++) {
                    token.nextToken();
                    if (token.ttype == StreamTokenizer.TT_NUMBER) {
                        rewardMatrix[i][j] = token.nval;
                        wallMatrix[i][j] = false;
                    } else {
                        wallMatrix[i][j] = true;
                    }
                }
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        initialize();        
    }
	
	 private void initialize() {
		 	mentorActions = KnightAction.values();
		 	observerActions = KingAction.values();
	        observerActionIds = new int[observerActions.length];
	        mentorActionIds = new int[mentorActions.length];
	        for (int i = 0; i < observerActions.length; i++) {
	            observerActionIds[i] = observerActions[i].getActionId();
	        }	   
	        for (int i = 0; i < mentorActions.length; i++) {
	            mentorActionIds[i] = mentorActions[i].getActionId();
	        }
	        stateLabels = new int[xDim][yDim];
	        int count = 0;
	        for (int i = 0; i < xDim; i++) {
	            for (int j = 0; j < yDim; j++) {
	                if(!wallMatrix[i][j]) {
	                    stateLabels[i][j] = count;
	                    stateList.add(new Coordinate(i, j));
	                    count++;

	                }
	            }
	        }
	        numStates = count;
	 }
	 
	 public Coordinate nextState(Coordinate s, PieceAction a){
		 //Implement this with a small amount of noise
		 Random r = new Random();
		 int newX = s.getX() + a.dx();
		 int newY = s.getY() + a.dy();
		 if (newX < 0 || newX > xDim -1 || newY < 0 || newY > yDim -1 ||
			 (wallMatrix[newX][newY])){
			 return s;
		 } else {
			 if (r.nextDouble()<NOISE_LEVEL){
				 //Noise!
				 int dir = r.nextInt(4);
				 switch (dir){
				 	case 0: if (newY > 0){newY--;} 
				 	case 1: if (newX > 0){newX--;} 
				 	case 2: if (newY < yDim-1){newY++;} 
				 	case 3: if (newX < xDim-1){newX++;} 
				 }
			 }
			 return new Coordinate(newX, newY);
		 }
		 
		 
	 }
	 
	  
	 public boolean isTerminalState(int stateId) {
	        Coordinate coords = getStateCoords(stateId);
	        if (rewardMatrix[coords.getX()][coords.getY()] != 0){
	            return true;
	 		}else{
	            return false;
	 		}
	 }
	 
	 public double getReward(int state) {
	        Coordinate coord = getStateCoords(state);
	        return rewardMatrix[coord.getX()][coord.getY()];
	  }
	 
	 public double getReward(int state, int action) {
	        Coordinate coord = getStateCoords(state);
	        return rewardMatrix[coord.getX()][coord.getY()];
	  }
	 public Coordinate getStateCoords(int stateId) {
	        return stateList.get(stateId);
	 }
	 
	 public int getNextState(int stateId, PieceAction action){
		 return getNextState(getStateCoords(stateId), action);
	 }
	 
	 private int getNextState(Coordinate coords, PieceAction action) {
	        int nextX = coords.getX() + action.dx();
	        int nextY = coords.getY() + action.dy();
	        if (nextX < 0 || nextY < 0 || nextX >= xDim || nextY >= yDim || wallMatrix[nextX][nextY]) {
	            nextX = coords.getX();
	            nextY = coords.getY();
	        }
	        return getStateId(nextX, nextY);
	 }
	 protected int getStateId(int x, int y) {
		 return stateLabels[x][y];
	 }
}
